%   main_program.m
%   Main program for the control of manipulators
%   Author: LuÃ­s Louro, llouro@dei.uminho.pt
%           Estela Bicho, estela.bicho@dei.uminho.pt
%   % Copyright (C) 2024
%   2024/02/19
%--------------------------------------------------------------------------
% Before running this script, open the scenario in CoppeliaSim, e.g
% Do not run simulation!
%--------------------------------------------------------------------------
clear

robot_name = 'LBR_iiwa_14_R820';

% need to choose the gripper/hand
hand_name = 'RG2';

%Number of targets for each colour of box
LATA_SALSICHAS_1 = 1;
LATA_SALSICHAS_2 = 2;
LATA_SALSICHAS_3 = 3;
LATA_COGUMELOS_1 = 4;
LATA_COGUMELOS_2 = 5;
LATA_COGUMELOS_3 = 6;

%Number of positions in the shelfes
%1st 48 left shelf Rack 6 -> Rack 1
%2st 48 right shelf Rack 1 -> Rack 6
max_positions = 96;

%Number of proximity sensors for the shelfes
%positioned in the same way as the positions
max_prox_shelf = 96;

% Creation of a communication class object with the simulator
[sim,error_sim] = simulator_interface();
if(error_sim==1)
    return;
end

%Creation of a communication class object with the manipulator arm
[robot_arm,error_man] = arm_interface(sim,robot_name,hand_name);
if error_man == 1
    sim.terminate();
    return;
end

[error,timestep] = sim.get_simulation_timestep();
%get time step value (normally dt=50ms)
if error == 1
    sim.terminate();
    return;
end
[error,nJoints,Links,DistanceHand,MinPositionJoint,MaxPositionJoint] = robot_arm.get_RobotCharacteristics();
if error == 1
    sim.terminate();
    return;
end

%--------------------------------------------------------------------------
%error = sim.move_conveyorbelt(); %Put the conveyor belt in motion
if error == 1
    sim.terminate();
    return;
end

error = robot_arm.open_hand(); %Initialize with hand opened
if error == 1
    sim.terminate();
    return;
end

start = tic;
m=1;
stop=0;

%%%%%%%%%%%%%%%% INITIALIZATION %%%%%%%%%%%%%%%%

%% KUKA MOBILE

% Creation of a communication class object with the robot
%Input:
% sim - pointer to class kuka_interface
%Output:
% vehicle - pointer to class kuka_interface
[vehicle,error_kuka] = kuka_interface(sim);
if(error_kuka==1)
    return;
end

%This function returns relevant information about the mobile platform 
[error,rob_W,rob_L,theta_obs] = vehicle.get_RobotCharacteristics();
%Output:
% error = 1 - error in function
% rob_W - robot width (cm)
% rob_L - robot lenght (cm)
% theta_obs - Vector with angle value for each sector of obstacle dynamic 
% i (i = 1, . . . , 29) relative to the frontal direction (in rad)
if(error==1)
    return;
end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Initialize the mobile platform with zero speeds
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
vrobot_y = 0.0;     %cm/s
vrobot_x = 0.0;     %cm/s
wrobot = 0.0;       %rad/s
error = 0;
vel_front_left = 0.0;   %rad/s
vel_front_right = 0.0;  %rad/s
vel_rear_left = 0.0;    %rad/s
vel_rear_right = 0.0;   %rad/s

% Convert longitudinal speed, lateral speed and angular speed into wheel 
% speed
[error,vel_front_left,vel_front_right,vel_rear_left,vel_rear_right] = vehicle.Kinematics_vehicle(wrobot, vrobot_y,vrobot_x);
if(error==1)
    return;
end

% Set wheels speeds
[error, ~, ~, phi] = vehicle.set_velocity(vel_front_left,vel_front_right,vel_rear_left,vel_rear_right);
if(error==1)
    return;
end

%%%%%%%%%%%%%%%%%%%%%%%%%
%       KUKA TARGETS
%%%%%%%%%%%%%%%%%%%%%%%%%

tg_land =   1;
tg_idle =   2;
tg_right =  3;
tg_left =   4;
tg_error =  5;

target_kuka = 0;

[error, tgt_pos] = sim.get_KUKAtarget_position(tg_idle);

if error 
    fprintf("ERROR GETTING KUKA TARGETS\n");
    return
end

sig_reached = 0;

%% OTHER VARIABLES
%vision
[~,top_image] = sim.innit_top_Image();
[~,conv_image] = sim.innit_conv_Image();
[vision] = vision();

[~, arm_pos] = robot_arm.get_robot_position;

%% ARM INITIALIZATION
% Initialize combined control object
arm_control = arm_Kinematics(robot_arm, Links, MaxPositionJoint, MinPositionJoint, arm_pos);
pickNplace = pick_n_place(control, MaxPositionJoint, MinPositionJoint);

theta_steps = 20;
steps_count = 1;
steps_count2 = 1;

posi_sig_count = 0;
posi_sig_max = 0;
iterations = 0;

%% FSM control 

st_idle =           0;
st_docking =        1;
st_registation =    2;
st_conv_pick =      3;
st_interm_place =   4;
st_transit =        5;
st_interm_pick =    6;
st_shelf_place =    7;

sig_finished = 1;
sig_working = 0;
sig_picked = 0;

curr_st = st_idle;
next_st = st_idle;
prev_st = st_idle;
update_st = 0;

% ---- FSM inside each state
stage = 0;          


%% CAN ORGANIZATION
% Right :: shelve mushrooms     -> type 1
% Left  :: shelve sausages      -> type 2

shelf_sig = 0;                  % 0 -> type 2 || 1 -> type 1

stock_manager = Stock_Manager; 

%% Movement flags

move_arm = 0;
move_kuka = 0;

%% MAIN LOOP
while stop==0
    %----------------------------------------------------------------------
    %% Robot interface
    % set and get information to/from vrep
    % avoid do processing in between ensure_all_data and trigger_simulation
    sim.ensure_all_data();
    
    % Convert longitudinal speed, lateral speed and angular speed into wheel 
    % speed
    [error,vel_front_left,vel_front_right,vel_rear_left,vel_rear_right] = vehicle.Kinematics_vehicle(wrobot, vrobot_y,vrobot_x);
    if(error==1)
        return;
    end

    [error,x, y, phi] = vehicle.set_velocity(vel_front_left,vel_front_right,vel_rear_left,vel_rear_right);
    if(error==1)
        return;
    end

     %[x, y, phi_2pi] = vehicle.get_vehicle_pose2pi();

    % trigger obstacles data reception
    error = vehicle.trigger_obstacles();
    % error = 1 - error in function
    if(error==1)
        return;
    end

    [error,dist] = vehicle.get_DistanceSensorAquisition(true, false);
    if(error==1)
        return;
    end

    % ReadArmJoints - get joint value (rad) for arm
    [error,ReadArmJoints] = robot_arm.get_joints();
    if error == 1
        sim.terminate();
        return;
    end

    % armPosition - get robot position
    [error,armPosition] = robot_arm.get_robot_position();
    if error == 1
        sim.terminate();
        return;
    end

    % objectPosition - get object position
    %[error,objectPosition]=sim.get_object_position(LATA_SALSICHAS_1);
    if error == 1
        sim.terminate();
        return;
    end

    % objectPosition - get target position
    %[error,targetPosition]=sim.get_target_position(PRATELEIRA1_FRENTE1);
    if error == 1
        sim.terminate();
        return;
    end

    %get simulation time
    [error,sim_time] = sim.get_simulation_time();
    if error == 1
        sim.terminate();
        return;
    end 

    %trigger simulation step
    sim.trigger_simulation();
    %----------------------------------------------------------------------
    % --- YOUR CODE --- %

    %Functions that allows open/close the hand
    %error = robot_arm.open_hand();     %open
    %error = robot_arm.close_hand();    %close
    %if error == 1
    %    sim.terminate();
    %    return;
    %end

    %% TEST
    
    % [~,targetPosition]=sim.get_KUKAtarget_position(3);
    % kuka_pos(1) = x;
    % kuka_pos(2) = y;
    % %disp(targetPosition);
    % [orientation, dist_target] = moveKuka(targetPosition(1), targetPosition(2), y,x, theta_obs, rob_W, rob_L, dist, timestep, phi);
    % %[rotation, v_y, v_x] = Docking_Kuka(orientation, dist_target, 3, kuka_pos, targetPosition);
    % wrobot = rotation;
    % % vrobot_x = v_x;
    % % vrobto_y = v_y;
    % if isinf(v_x)
    %     vel_x = 0;
    % end
    % if(wrobot > 0.3)
    %     vrobot_x = 0;
    %     vrobto_y = 0; 
    % else
    %     vrobot_x = v_x;
    %     vrobto_y = v_y;
    % end
    % %vrobot_x = vel_x;
    % fprintf("Vx: %d ; Vy: %d ; rot: %d ; dist_target: %d\n", vrobot_x, vrobto_y, wrobot, dist_target)
    % fprintf("KUKA position X: %d, Y: %d\n", x,y);

    %% FSM
    
    [~,prox_conveyor] = sim.get_conveyor_sensor_value();

    if update_st 
        update_st = 0;
        prev_st = curr_st;
        curr_st = next_st;

        % Reset Variables
        stg = 1;

        % counters reset
        posi_sig_count = 0;
        iterations = 0;
        steps_count = 0;
        
        % flags for movement 
        move_kuka = 0;
        move_arm = 0;

        %signals
        sig_reached = 0;
                
    end
    
    switch curr_st
    
        case st_idle                    % -> Initial and end state 
            %% IDLE STATE

            % Move KUKA to Idle Position
            target_kuka = tg_idle;

            % Move Arm to Idle Position

            [error, theta_sol, all_pos, ee_pos] = pickNplace.idle(armPosition, ReadArmJoints);

            if error ~= 1
                fprintf("--> ERROR ocurred: #%d\n", error);
            end
            
            posi_sig = control.check_positions(ReadArmJoints, ee_pos, stage);
            
            if posi_sig 
                posi_sig_count = posi_sig_count + 1;
            end

            % Check conditions
            if dist_target < 0.3 && posi_sig_count > 30
                % counters reset
                posi_sig_count = 0;
                iterations = 0;
                steps_count = 0;
                
                % flags for movement 
                move_kuka = 0;
                move_arm = 0;
                
                % states update
                update_st = 1;
                prev_st = curr_st;
                next_st = st_transit;
                stg = 1;
            else

                move_kuka = 1;
                move_arm = 1;
            end

        case st_registation             % -> Can detection and registation

            % Get Vision & Check Vision
            if prox_sensor
                [~, image] = sim.get_conv_Image();
            end
            output = pyrunfile("Vision_ML/sai.py", img=image);
            % Update Value & Register Can 

        case st_conv_pick               % -> Pick from the conveyor 
            %% CONVEYOR PICK STATE
            
            switch stg
                case 1          % Go near the target
                case 2          % Check prox signal, use vision
                case 3          % intermediate position pick_can
                case 4          % Pick can 
                
            end
            
            if sig_finished
                 % counters reset
                posi_sig_count = 0;
                iterations = 0;
                steps_count = 0;
                
                % flags for movement 
                move_kuka = 0;
                move_arm = 0;
                
                % states update
                update_st = 1;
                prev_st = curr_st;
                next_st = st_interm_place;
                stg = 1;
            end
                

        case st_interm_place            % -> Place can on car
            %% PLACE STORAGE STATE


        case st_transit                 % -> Move from conv <-> shelf
            %% TRANSIT STATE
            
            % check if there are cans in storage or on the hand
            storage_info = stock_manager.get_storage_info();
            if storage_info.quantity > 0
                count = 0;
                temp = 0;

                %check which type has more cans
                for i=1 : 9 
                    if storage_info.type(i) == 1
                        count = count + 1;
                    end
                end
                
                temp = storage_info.quantity - count;

                if temp >= 0                            % -> go to Left Shelve
                    target_kuka = tg_left;
                    shelf_sig = 1;
                else                                    % -> go to Right Shelve 
                    target_kuka = tg_right;
                    shelf_sig = 0;
                end
                
                next_st = st_interm_pick;

            else
                
                %Go to conveyor position
                target_kuka = tg_land;
                next_st = st_conv_pick;

            end

            if sig_reached
                update_st = 1;
            else
                move_kuka = 1;
            end

        case st_interm_pick             % -> Pick from car
            %% PICK STORAGE STATE


        case st_shelf_place             % -> Place can on shelf
            %% PLACE STORAGE STATE



    end
    
    %% ARM MOVEMENT
    
    if move_arm            % move joints 
        curret_theta = curret_theta + (theta_sol - curret_theta)*gain;
        robot_arm.set_joints(curret_theta);
    end

    %% KUKA MOVEMENT
    
    if (move_kuka && ( curr_st == st_transit || curr_st == st_idle )) && ~sig_reached
        
        [~,targetPosition]=sim.get_KUKAtarget_position(target_kuka);
        kuka_pos(1) = x;
        kuka_pos(2) = y;
        [orientation, dist_target] = moveKuka(targetPosition(1), targetPosition(2), y,x, theta_obs, rob_W, rob_L, dist, timestep, phi);
        [rotation, v_yrobot, v_xrobot] = Docking_Kuka(orientation, dist_target, next_st, targetPosition, kuka_pos );

    else
        vrobot_x = 0;
        vrobot_y = 0;
        sig_reached = 1;
    end

    %% BUG ARM

    if iterations > 250
        if curr_st == st_place
            override = 1;
        else
            stage = st_idle;
            posi_sig_count = 0;
            sig_finished = 1;
            sig_working = 0;
            steps_count = 0;
            stg = 1;
            prev_st = curr_st;
            iterations = 0;
        end
    elseif can_count > 6
        can_count = 0;
        % fprintf("**END OF PICK and PLACE**\nNo more targets, returning to idle position\n");
        stage = st_idle;
        posi_sig_count = 0;
        sig_finished = 1;
        sig_working = 0;
        steps_count = 0;
        stg = 1;
        prev_st = curr_st;
        iterations = 0;
        [~, theta_sol, all_pos, ee_pos] = pickNplace.idle(armPosition, ReadArmJoints);
    else
        override = 0;
    end
    
    %% CONVEYOR CONTROL
    if prox_conveyor
        disp("STOPPING Conveyor")
        error = sim.stop_conveyorbelt();            %stop
    else 
        disp("MOVING Conveyor")
        error = sim.move_conveyorbelt();            %motion
    end

    if error == 1
       sim.terminate();
       return;
    end

    m=m+1;
    %----------------------------------------------------------------------
    %It allows to guarantee a minimum cycle time of 50ms for the
    %computation cycle in Matlab
    time = toc(start);
    if time<0.05
        pause(0.05-time);
    else
        pause(0.01);
    end
    start = tic;
    %----------------------------------------------------------------------
end
error = sim.terminate();